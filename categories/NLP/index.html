<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: NLP - SAIのBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SAIのBlog"><meta name="msapplication-TileImage" content="C:\Users\11283\Pictures\icon\011-warning.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SAIのBlog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="SAIのBlog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="SAIのBlog"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="SAI_MUD"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"SAIのBlog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"SAI_MUD"},"publisher":{"@type":"Organization","name":"SAIのBlog","logo":{"@type":"ImageObject","url":{"text":"SAI"}}},"description":""}</script><link rel="icon" href="C:\Users\11283\Pictures\icon\011-warning.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">SAI</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/fatecantkillme"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">Categories</a></li><li class="is-active"><a href="#" aria-current="page">NLP</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-05-10T06:56:35.000Z" title="2025/5/10 14:56:35">2025-05-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-05-12T06:16:02.930Z" title="2025/5/12 14:16:02">2025-05-12</time></span><span class="level-item"><a class="link-muted" href="/categories/NLP/">NLP</a></span><span class="level-item">an hour read (About 8559 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/05/10/NLP1/">Pre-train, Prompt, and Predict A Systematic Survey of Prompting Methods in Natural Language Processing</a></p><div class="content"><span id="more"></span>

<p>传统的监督学习采用直接输入与直接输出结果的方式来完成任务。但是基于prompt的学习能够只改变prompt模板就能得到从预测生成的文本中分离出来的结果。这种方式明显更具有通用性，前提是有一个巨大的预训练模型和好的prompt templete。本篇论文介绍了从选择预训练模型到如何组织prompt到微调策略</p>
<h2 id="两个巨大改变"><a href="#两个巨大改变" class="headerlink" title="两个巨大改变"></a>两个巨大改变</h2><p>第一阶段：纯监督学习：主要依靠<strong>特征工程</strong>，依靠工程师手工找特征，然后用最大熵回归之类的传统机器学习模型来训练</p>
<p>第二阶段：神经网络的阶段：此时神经网络可以自动找到特征，故而重点变成<strong>如何架构</strong>一个好的神经网络模型以更好地学习更多的特征</p>
<p>transformer提出之后转向：预训练＋微调</p>
<p><strong>LM：语言模型是一种能够计算出任何给定文本片段（观察到的文本数据）作为一个自然、合理的语言序列出现的概率的系统。</strong></p>
<p>此时重心转向目标工程，具体就是深入思考在特定阶段（预训练或微调）希望模型学习到什么样的能力，根据这个期望，<strong>设计或组合能够有效引导模型学习这些能力的训练任务和相应的数学表达（即损失函数）</strong>。</p>
<p>到了2021，大家已经不再面对各种特定的任务做微调生成一个新模型，而是用一个大型的pre-train的模型加prompt 做few-shot learning.此时重心来到了<strong>prompt engine</strong>找到最好的prompt</p>
<h2 id="正式的prompt描述"><a href="#正式的prompt描述" class="headerlink" title="正式的prompt描述"></a>正式的prompt描述</h2><p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/10/681f054e91106.png"><img src="https://img.picui.cn/free/2025/05/10/681f054e91106.png" alt="image-20250510154247587.png"></a></p>
<ul>
<li><p>cloze prompt：z在prompt中间</p>
</li>
<li><p>prefix prompt：z在prompt最后面</p>
</li>
</ul>
<p>可以用<strong>虚拟词</strong>替代自然语言prompt</p>
<p><strong>答案搜索阶段</strong>，我们把所有可能的z都填入，通过LM预测概率</p>
<p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/10/681f0b00d1f7b.png"><img src="https://img.picui.cn/free/2025/05/10/681f0b00d1f7b.png" alt="QQ截图20250510161448.png"></a></p>
<p><strong>答案映射阶段</strong>，我们把很多的输出映射为同一结果</p>
<p>下文会谈论的：</p>
<p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/10/681f0b4ddf8de.png"><img src="https://img.picui.cn/free/2025/05/10/681f0b4ddf8de.png" alt="QQ截图20250510161611.png"></a></p>
<h2 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h2><h3 id="trainning-objectives"><a href="#trainning-objectives" class="headerlink" title="trainning objectives"></a>trainning objectives</h3><p>标准LM：从左到右的自回归模型，逐个词元预测</p>
<p><strong>去噪目标：</strong></p>
<ol>
<li>CTR（Corrupted Text Reconstruction）：只要求重建损坏的部分，loss不计入其余token</li>
<li>FTR（Full Text Reconstruction）：要求重建全文，loss计入所有token</li>
</ol>
<p>从左到右的自回归模型更适用于prefix prompt,而重建目标的模型更适用于cloze prompt</p>
<p><strong>不同的加噪方式会对模型能力有不同的影响</strong></p>
<p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/10/681f126473c68.png"><img src="https://img.picui.cn/free/2025/05/10/681f126473c68.png" alt="QQ截图20250510164608.png"></a></p>
<p>masking：可以随机，也可以只mask某类词汇以增强模型的某种先验知识</p>
<h3 id="representation-direction"><a href="#representation-direction" class="headerlink" title="representation direction"></a>representation direction</h3><ul>
<li>从左到右</li>
<li>双向</li>
</ul>
<p>通常实现方式都是attention masking</p>
<p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/10/681f13cf98a86.png"><img src="https://img.picui.cn/free/2025/05/10/681f13cf98a86.png" alt="QQ截图20250510165231.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/10/681f14241c4b0.png"><img src="https://img.picui.cn/free/2025/05/10/681f14241c4b0.png" alt="QQ截图20250510165353.png"></a></p>
<p>L2R LMs：</p>
<ul>
<li><strong>decoder-only的泛化性能更好</strong><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=640486327&content_type=Answer&match_order=1&q=ICML+22&zhida_source=entity">ICML 22</a>的<a href="https://link.zhihu.com/?target=https://proceedings.mlr.press/v162/wang22u/wang22u.pdf">What language model architecture and pretraining objective works best for zero-shot generalization?.</a> 在最大5B参数量、170B token数据量的规模下做了一些列实验，发现用next token prediction预训练的decoder-only模型在各种下游任务上zero-shot泛化性能最好；另外，许多工作表明decoder-only模型的few-shot（也就是上下文学习，in-context learning）泛化能力更强</li>
<li>预训练的难度更低</li>
<li>并没有一个明确的研究表明decoder-only一定更好</li>
</ul>
<p>masked language models:</p>
<ul>
<li>encoder-only在分类这样的下游任务上表现更好</li>
</ul>
<p>prefix LMs&amp;encoer-decoder:</p>
<ul>
<li><p>兼顾理解和生成能力</p>
</li>
<li><p>由于这两种不适应非生成任务，故而使用prompt可以把非生成任务转化为生成任务</p>
</li>
</ul>
<h2 id="prompt-engineering"><a href="#prompt-engineering" class="headerlink" title="prompt engineering"></a>prompt engineering</h2><h3 id="prompt-shape："><a href="#prompt-shape：" class="headerlink" title="prompt shape："></a>prompt shape：</h3><ol>
<li>cloze prompt</li>
<li>prefix prompt</li>
</ol>
<h3 id="离散prompt：实际的，人类可读的prompt"><a href="#离散prompt：实际的，人类可读的prompt" class="headerlink" title="离散prompt：实际的，人类可读的prompt"></a>离散prompt：实际的，人类可读的prompt</h3><p>D1提示挖掘：</p>
<ol>
<li>给定一组训练数据，包含输入x和输出y</li>
<li>在大型语料库中搜索包含x和y的字符串</li>
<li>找出x与y之间的中间词语或者句子成分中的语法关系</li>
<li>那些存在频率很高的中间词或者语法关系就可以作为模板</li>
<li>如：[x]中间词+中间语法关系[y]</li>
</ol>
<p>D2提示改写：</p>
<ol>
<li>获得种子prompt（人工手写或者挖掘）</li>
<li>通过不同方式将其改写成多个prompt如：来回翻译、同义词替换、专门的神经网络重写</li>
<li>选择那个能在目标任务上获得最高训练准确率的prompt</li>
</ol>
<p>D3基于梯度的搜索：</p>
<ol>
<li>方法会一步步地、迭代地尝试不同的词元组合来构成提示。在每一步，它会评估当前词元选择的好坏，并尝试替换或添加能够使模型输出更接近期望目标的词元。</li>
</ol>
<p>D4提示生成：</p>
<ol>
<li>将x与y中间填充空，让一个模型来填充这些空</li>
</ol>
<p>D5提示评分：</p>
<ol>
<li>获取候选模板库</li>
<li>将x与y填入模板</li>
<li>使用LM对填入后的句子做概率预测</li>
</ol>
<h3 id="连续prompt"><a href="#连续prompt" class="headerlink" title="连续prompt"></a>连续prompt</h3><ul>
<li><p>让prompt不一定是自然语言，而是训练出来的能够更好适应下游任务的向量</p>
</li>
<li><p>让模版有自己的可调参数，而不用调整预训练模型本身的参数，更加灵活</p>
</li>
</ul>
<p>C1:前缀微调</p>
<p>前缀在每一层的K和Q都直接由前缀矩阵的参数直接生成而不是依赖原模型的矩阵参数</p>
<p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/10/681f536ff0ca6.png"><img src="https://img.picui.cn/free/2025/05/10/681f536ff0ca6.png" alt="QQ截图20250510212332.png"></a></p>
<p><strong>Lester et al. (2021)</strong> 的方法与此类似，他们也是在输入序列前添加特殊标记（tokens）来构成一个模板，并直接调整这些特殊标记的嵌入（embeddings）。与 Li 和 Liang 的方法相比，这种方法引入的参数更少，因为它<strong>不会在每个网络层内引入额外的可调参数</strong>，而仅仅是调整输入层特殊标记的嵌入。</p>
<p><strong>Tsimpoukelli et al. (2021)</strong> 训练了一个视觉编码器，该编码器将图像编码成一个嵌入序列，这个序列可以作为提示（prompt）来引导一个冻结的自回归语言模型生成相应的图像描述。他们证明了由此产生的模型可以在视觉-语言任务（如视觉问答）上实现少样本学习（few-shot learning）。</p>
<p>C2：使用离散提示初始化的调优</p>
<p><strong>具体方法</strong>：</p>
<ul>
<li>这类方法不从零开始学习连续提示，而是利用已经通过离散提示搜索方法创建或发现的提示来初始化连续提示的搜索过程。这样做的好处是，离散提示（通常由人类可读的词语构成）可以为连续提示的优化提供一个更好的起点。</li>
</ul>
<p>C3：硬提示-软提示混合调优 </p>
<p>这类方法不完全依赖于可学习的软提示模板，而是在一个固定的“硬提示”模板（通常由真实词汇构成）中插入一些可调整的嵌入（软提示）。</p>
<h2 id="answer-engineering"><a href="#answer-engineering" class="headerlink" title="answer engineering"></a>answer engineering</h2><h3 id="Answer-Shape"><a href="#Answer-Shape" class="headerlink" title="Answer Shape"></a>Answer Shape</h3><p>主要是粒度区分：</p>
<ul>
<li>Tokens</li>
<li>Span：几个token长度–cloze prompt</li>
<li>Sentence：–prefix prompt</li>
</ul>
<p>根据任务选择shape：分类任务选择token或者span，多选项问题回答用sentence</p>
<h3 id="Answer-Space"><a href="#Answer-Space" class="headerlink" title="Answer Space"></a>Answer Space</h3><ul>
<li><p>无约束空间：包含所有的tokens，生成的就是答案</p>
</li>
<li><p>受约束空间：分类任务、实体识别任务、多项选择</p>
</li>
</ul>
<h4 id="分离答案搜索"><a href="#分离答案搜索" class="headerlink" title="分离答案搜索"></a>分离答案搜索</h4><p><strong>1. 答案改写 (Answer Paraphrasing)</strong></p>
<ul>
<li><strong>核心思想：</strong> 从一个初始的答案集合（可能是人工设定的）出发，通过“改写”（paraphrasing）技术（比如来回翻译）来扩展这个集合，使其能够覆盖更多语言模型可能输出的、表达相同含义的答案形式。</li>
</ul>
<p><strong>2. 先剪枝后搜索 (Prune-then-Search)</strong></p>
<ul>
<li><strong>核心思想：</strong> 这类方法通常分两步进行。首先，创建一个初始的、经过“剪枝”的答案空间 Z′（选择频率高的词元或者使用LM生成），这个空间包含一些貌似合理的候选答案词，数量相对较少。然后，再在这个缩小的空间内运行一个更精细的搜索算法（最大似然、逻辑分类器），以挑选出最终的答案词（或答案词集合）。</li>
</ul>
<p><strong>3. 标签分解 (Label Decomposition)</strong></p>
<ul>
<li><strong>核心思想：</strong> 特别是在处理复杂标签（如关系抽取任务中的关系标签）时，将标签本身分解为其构成词，并将这些构成词的集合作为模型需要生成的答案。</li>
</ul>
<h2 id="多提示学习方法"><a href="#多提示学习方法" class="headerlink" title="多提示学习方法"></a>多提示学习方法</h2><h3 id="提示集成-Prompt-ensembling-是指在推理时针对一个输入使用多个提示-prompts-来进行预测的过程。"><a href="#提示集成-Prompt-ensembling-是指在推理时针对一个输入使用多个提示-prompts-来进行预测的过程。" class="headerlink" title="提示集成 (Prompt ensembling) 是指在推理时针对一个输入使用多个提示 (prompts) 来进行预测的过程。"></a>提示集成 (Prompt ensembling) 是指在推理时针对一个输入使用多个提示 (prompts) 来进行预测的过程。</h3><p>(1) 可以 <strong>利用不同 prompt 的互补优势 (leverage the complementary advantages of different prompts)</strong>。因为不同的 prompt 可能在处理某些类型的输入或捕捉某些信息时表现更好，集成起来可以取长补短。 </p>
<p>(2) 可以 <strong>降低 prompt engineering 的成本 (alleviate the cost of prompt engineering)</strong>。因为要找到表现最好的那 <strong>一个</strong> prompt 是非常困难且耗时的，通过集成多个 prompt，就不用非得找到那个“完美”的 prompt。</p>
<p>(3) 可以 <strong>稳定在下游任务上的表现 (stabilize performance on downstream tasks)</strong>。集成方法通常能让结果更稳健，不容易受到某个特定 prompt 不稳定的影响。</p>
<p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/11/68200f0a300d9.png"><img src="https://img.picui.cn/free/2025/05/11/68200f0a300d9.png" alt="QQ截图20250511104402.png"></a></p>
<p><strong>均匀平均 (Uniform averaging)</strong></p>
<p>当使用多个提示时，组合预测结果最直观的方法是对来自不同提示的概率取平均值</p>
<p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/11/68200f7368410.png"><img src="https://img.picui.cn/free/2025/05/11/68200f7368410.png" alt="QQ截图20250511104603.png"></a></p>
<p><strong>Weighted averaging (加权平均)</strong></p>
<p>为每个prompt分配权重，这个权重往往是事先通过prompt在训练集上的准确率来预先设定，Qin 和 Eisner (2021) 还引入了一种 <strong>依赖于数据 (data-dependent)</strong> 的加权策略。在这种策略下，在确定不同 prompt 的权重时，也会考虑输入数据与该 prompt 的相关性或输入数据出现在该 prompt 中的概率。</p>
<p><strong>Majority voting (多数投票)</strong></p>
<p>多数投票的基本思想是：每个 prompt 都对输入进行分类，给出一个预测类别，最后<strong>统计哪个类别被预测的次数最多（获得“多数票”）</strong>，就将该类别作为最终的预测结果。</p>
<p><strong>Knowledge distillation (知识蒸馏)</strong></p>
<p>一组深度学习模型的集成（ensemble，即多个模型组合起来）通常可以提升性能。而这种更优越的性能可以通过 <strong>知识蒸馏 (knowledge distillation)</strong> 的方法转移或“蒸馏”到一个 <strong>单一的模型 (single model)</strong> 中。</p>
<p>首先用多个 prompt 各自对应的模型组成一个**“教师”集成模型，用它来给无标签数据打标签，**然后训练一个“学生”单一模型去学习这个带标签的数据集，从而把集成模型的知识学到单个模型里。</p>
<p><strong>Prompt ensembling for text generation (用于文本生成的提示词集成)</strong></p>
<p>一种简单的集成方法是使用标准的文本生成技术（比如贪婪搜索、束搜索等），但在生成答案序列中的 <strong>下一个词 (next word)</strong> (zt) 时，是基于所有 prompt 预测的下一个词概率的 <strong>集成（平均）概率 (ensembled probability)</strong> 来决定。</p>
<p>Schick 和 Schütze (2020) 的做法是为每一个 prompt fprompt,i(x) <strong>单独训练了一个模型 (separate model)</strong>（很可能是对一个基础语言模型进行了微调）。他们首先使用 <strong>每个单独训练好的模型分别进行文本生成 (decode generations using each model)</strong>，得到各自生成的完整文本序列。然后，他们通过平均 <strong>所有模型对某个生成的文本序列的生成概率 (averaging their generation probability across all models)</strong> 来对每一个生成的文本序列进行评分。简单来说，不是在生成过程中每一步都平均概率，而是先各自生成完整文本，再对生成的文本根据所有模型的概率进行打分，最后选择分数最高的文本。</p>
<h3 id="Prompt-Augmentation-提示词增强"><a href="#Prompt-Augmentation-提示词增强" class="headerlink" title="Prompt Augmentation (提示词增强)"></a>Prompt Augmentation (提示词增强)</h3><p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/11/68200f0a300d9.png"><img src="https://img.picui.cn/free/2025/05/11/68200f0a300d9.png" alt="QQ截图20250511104402.png"></a></p>
<p><strong>演示学习 (demonstration learning)</strong></p>
<p>你不再只是简单地给一个 prompt ：“中国的首都是[Z]。” 而是可以在前面加上几个示例，比如：“英国的首都是伦敦。日本的首都是东京。中国的首都是[Z]。” 这样就通过前面的示例向模型展示了回答这类问题的模式。</p>
<p>(1) <strong>示例选择 (Sample Selection):</strong> 如何从可能的示例中，选择出最有效、最有帮助的那些？</p>
<p> (2) <strong>示例排序 (Sample Ordering):</strong> 选定的示例应该按照什么顺序排列？以及它们应该放在实际 prompt 的前面还是后面，如何组织？</p>
<p><strong>Sample Selection (示例选择)</strong></p>
<p>在 few-shot（少量示例）的场景下，<strong>所使用的示例的选择对于模型性能影响非常大</strong>。表现可能从在某些任务上接近当前最优水平 (near state-of-the-art accuracy) 到接近随机猜测 (near random guess) 不等。</p>
<p>**Gao 等人 (2021) 和 Liu 等人 (2021a) 使用了 **句子 embedding (sentence embeddings)来选择示例。具体方法是，在句子 embedding 空间中，选择那些与需要模型处理的 <strong>输入 (input)</strong> 比较接近（距离近）的示例作为演示。这个思路是希望通过选择与当前任务输入在语义或结构上相似的示例来提高效果。</p>
<p>为了衡量预训练语言模型基于指令执行新任务的 <strong>泛化能力 (generalization capability)</strong>，Mishra 等人 (2021) 在示例中同时提供了 <strong>正面示例 (positive samples)</strong> 和 <strong>反面示例 (negative samples)</strong>。反面示例的作用是强调模型应该 <strong>避免做的事情 (highlight things to avoid)</strong> 或常见的错误类型。</p>
<p><strong>Sample Ordering (示例排序)</strong></p>
<p>Lu et al. 发现，表现不佳的提示词顺序往往会导致模型预测分布严重不平衡，因此，他们假设具有较高全局熵的排列可能表现更好，因为它减轻了模型对特定标签的固有偏差。</p>
<p>对于每一个待评估的提示词排列顺序，Lu et al. 将其作为上下文输入到语言模型中，然后让模型对人工开发集中的每个示例进行预测。模型对于每个示例都会输出一个关于所有可能标签的概率分布。基于这些预测的概率分布，他们计算<strong>熵</strong>。熵在这里作为衡量模型对预测结果<strong>不确定性</strong>或<strong>预测分布均衡性</strong>的指标。</p>
<p>Kumar 和 Talukdar (2021) 采取的方法是，他们 <strong>搜索 (search)</strong> 一个好的训练示例排列顺序作为增强 prompt。此外，他们还学习了一个特殊的 <strong>分隔符 token (separator token)</strong> 放在每个示例 prompt 之间，以期进一步提升模型性能</p>
<h3 id="Prompt-Composition-提示词组合"><a href="#Prompt-Composition-提示词组合" class="headerlink" title="Prompt Composition (提示词组合)"></a>Prompt Composition (提示词组合)</h3><p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/11/68200f0a300d9.png"><img src="https://img.picui.cn/free/2025/05/11/68200f0a300d9.png" alt="QQ截图20250511104402.png"></a></p>
<p>对于那些可以基于更基础的 <strong>子任务 (subtasks)</strong> 进行组合的 <strong>可组合任务 (composable tasks)</strong>，我们也可以进行 <strong>提示词组合 (prompt composition)</strong>。这种方法是使用多个 <strong>子 prompt (sub-prompts)</strong>，每个子 prompt 对应一个子任务，然后基于这些子 prompt 来定义一个 <strong>组合 prompt (composite prompt)</strong>。</p>
<p>在 <strong>关系抽取任务 (relation extraction task)</strong> 中（这个任务的目标是抽取两个实体之间的关系），我们可以将这个任务分解成几个子任务，包括识别实体的特征 (identifying the characteristics of entities) 和对实体之间的关系进行分类 (classifying the relationships between entities)。</p>
<h3 id="Prompt-Decomposition-提示词分解"><a href="#Prompt-Decomposition-提示词分解" class="headerlink" title="Prompt Decomposition (提示词分解)"></a>Prompt Decomposition (提示词分解)</h3><p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/11/68200f0a300d9.png"><img src="https://img.picui.cn/free/2025/05/11/68200f0a300d9.png" alt="QQ截图20250511104402.png"></a></p>
<p>对于需要对同一个样本进行 <strong>多次预测 (multiple predictions)</strong> 的任务（例如 <strong>序列标注 (sequence labeling)</strong>，像命名实体识别或词性标注），直接针对整个输入文本 x 定义一个完整的、包含所有预测目标的 prompt 是很有挑战性的。</p>
<p>解决这个问题的一个直观方法是，将这个完整的 prompt 分解成不同的 <strong>子 prompt (sub-prompts)</strong>，然后 <strong>分别回答 (answer separately)</strong> 每一个子 prompt。</p>
<p>通过 <strong>命名实体识别 (named entity recognition - NER)</strong> 任务的例子来说明这个想法。NER 任务的目标是识别输入句子中的所有命名实体。</p>
<p>在 NER 这个例子中，首先会将输入的句子分解成多个 <strong>文本片段（span）</strong>。然后，可以针对 <strong>每一个片段</strong> 创建一个 prompt，让模型预测该片段的 <strong>实体类型 (entity type)</strong>（类型包括人名、地名等，也包括“不是实体”的类别）。</p>
<h2 id="Training-Strategies-for-Prompting-Methods-提示词方法的训练策略"><a href="#Training-Strategies-for-Prompting-Methods-提示词方法的训练策略" class="headerlink" title="Training Strategies for Prompting Methods (提示词方法的训练策略)"></a>Training Strategies for Prompting Methods (提示词方法的训练策略)</h2><p> <strong>零样本设置 (zero-shot setting)</strong>：对于当前关心的这个具体任务来说，没有使用任何训练数据。</p>
<p><strong>数据学习 (full-data learning)</strong>，使用相对大量（reasonably large number）的训练样本来训练模型；</p>
<p> <strong>少样本学习 (few-shot learning)</strong>，只使用非常少量的（very small number）样本来训练模型；</p>
<p>像 Prompt Engineering 这种方法，虽然不训练模型，但常常用任务数据来设计&#x2F;验证 prompt，这让它在严格意义上并非“纯粹”的零样本。</p>
<h3 id="Parameter-Update-Methods-参数更新方法"><a href="#Parameter-Update-Methods-参数更新方法" class="headerlink" title="Parameter Update Methods (参数更新方法)"></a>Parameter Update Methods (参数更新方法)</h3><p><a target="_blank" rel="noopener" href="https://img.picui.cn/free/2025/05/11/68202984a4c89.png"><img src="https://img.picui.cn/free/2025/05/11/68202984a4c89.png" alt="QQ截图20250511123704.png"></a></p>
<p><strong>Promptless Fine-tuning (无提示词微调)</strong></p>
<p>在这种策略下，给定一个特定任务的数据集，预训练语言模型（LM）的 <strong>所有参数 (all parameters)</strong> 或者 <strong>部分参数 (some parameters)</strong> 会根据下游任务训练样本产生的梯度进行更新（也就是训练）。</p>
<p>这是一种简单、强大且被广泛使用的方法，但是，它可能在 <strong>小型数据集 (small datasets)</strong> 上出现 <strong>过拟合 (overfit)</strong> 或者学习不稳定 (not learn stably) 的情况</p>
<p>模型还容易发生 <strong>灾难性遗忘 (catastrophic forgetting)</strong>。灾难性遗忘是指语言模型在微调后，丢失了它在微调之前（即预训练阶段）所具备的一些能力</p>
<p><strong>Tuning-free Prompting (无微调提示词)</strong></p>
<p><strong>不改变 (without changing)</strong> 预训练语言模型的任何参数，仅仅依靠提供的 prompt 来进行预测。</p>
<p>这种方法可以 <strong>选择性地 (optionally)</strong> 结合使用第 6.2 节介绍的 <strong>提示词增强 (prompt augmentation)</strong>，即在 prompt 中加入一些带答案的示例来增强输入。这种“无微调提示词”与“提示词增强”相结合的方式，也通常被称为 <strong>上下文学习 (in-context learning)</strong>（引用了 Brown 等人 2020 年的研究，GPT-3 的能力展示就属于这种</p>
<p>由于 prompt 是唯一指定任务要求的方式，因此需要大量的 <strong>人工设计&#x2F;工程 (heavy engineering)</strong> 来精心构造 prompt，才能达到较高的准确率。且上下文学习在示例多时推理慢</p>
<p> <strong>Fixed-LM Prompt Tuning (固定语言模型的提示词调优)</strong></p>
<p><strong>仅更新 (updates only)</strong> 这些 <strong>prompt 的参数 (prompts’ parameters)</strong>。它利用从下游训练样本中获取的 <strong>监督信号 (supervision signal)</strong> 进行训练，同时保持 <strong>整个预训练语言模型 (entire pre-trained LM)</strong> 的参数 <strong>完全不变 (unchanged)</strong>。</p>
<p><strong>适用于少样本场景 (suitable in few-shot scenarios)</strong>，在数据量较少时也能取得不错的效果。</p>
<p>通常情况下，它的准确率要 <strong>优于 (superior accuracy to)</strong> 无微调提示词（因为它毕竟进行了一些训练）。</p>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>不适用于零样本场景 (Not applicable in zero-shot scenarios)</strong>，因为它需要训练数据来更新 prompt 参数。</li>
<li>尽管在少样本场景下有效，但在数据量非常大 (large-data settings) 的情况下，由于只训练了很少一部分参数，其 <strong>表示能力 (representation power)</strong> 可能会受到限制（相比于训练整个大模型）。</li>
<li>仍然需要通过选择 <strong>超参数 (hyperparameters)</strong>（用于训练 prompt 参数）或初始的 <strong>种子 prompt (seed prompts)</strong> 来进行一定的 prompt engineering。</li>
<li>训练得到的 prompt 参数（例如一些向量）通常 <strong>不可被人直接解释或操纵 (not human-interpretable or manipulable)</strong>，不像文本 prompt 那样直观。</li>
</ul>
<p><strong>Fixed-prompt LM Tuning (固定提示词的语言模型调优)</strong></p>
<p><strong>调优（训练）语言模型的参数 (tunes the parameters of the LM)</strong>，这一点与标准的预训练加微调范式是一样的。但它额外地使用了参数 <strong>固定不变的 prompt (prompts with fixed parameters)</strong> 来指定模型的行为。</p>
<p><strong>优点 (Advantages):</strong></p>
<ul>
<li>使用 prompt 或答案工程可以更完整地指定任务，从而使得学习过程更加 高效 (efficient learning)，特别是在少样本场景下表现突出。</li>
</ul>
<p><strong>缺点 (Disadvantages):</strong></p>
<ul>
<li><p>仍然需要进行 prompt 或答案工程 (Prompt or answer engineering are still required)，尽管可能不像完全不训练模型的“无微调提示词”那样需要大量设计。</p>
</li>
<li><p>在一个下游任务上通过这种方法微调过的语言模型，可能 不适用于 (may not be effective on) 另一个不同的下游任务（因为它在微调过程中已经偏向了特定的任务，泛化性不如固定模型的 Prompting 方法）。</p>
</li>
</ul>
<p><strong>Prompt+LM Tuning (提示词 + 语言模型调优)</strong></p>
<p><strong>与 prompt 相关的新增参数 (prompt-relevant parameters)</strong>（比如软 prompt 的参数）。这些参数可以与预训练模型的 <strong>全部或者部分参数 (all or some of the parameters)</strong> 一起进行 <strong>联合微调（训练）(fine-tuned together)</strong>。</p>
<p><strong>优点 (Advantages):</strong></p>
<ul>
<li>这是所有方法中 <strong>表达能力最强 (most expressive method)</strong> 的一种，因为它同时训练了模型的许多参数和 prompt 相关的参数，具有最大的灵活性。</li>
<li>可能最适合在 <strong>高数据量 (high-data settings)</strong> 的情况下使用，能够充分利用大量数据。</li>
</ul>
<p><strong>缺点 (Disadvantages):</strong></p>
<ul>
<li>需要训练和存储模型的 <strong>所有参数 (all parameters)</strong>（或者大部分参数），这通常意味着需要更多的计算资源和存储空间。</li>
<li>在 <strong>小型数据集 (small datasets)</strong> 上进行训练时，由于参数量大，可能容易发生 <strong>过拟合 (May overfit)</strong>。</li>
</ul>
<h2 id="Applications-应用"><a href="#Applications-应用" class="headerlink" title="Applications (应用)"></a>Applications (应用)</h2><h3 id="Knowledge-Probing-知识探测"><a href="#Knowledge-Probing-知识探测" class="headerlink" title="Knowledge Probing (知识探测)"></a>Knowledge Probing (知识探测)</h3><p><strong>Factual Probing (事实性探测)</strong></p>
<p>量化预训练语言模型内部的表示（representations）中包含了多少 <strong>事实性知识 (factual knowledge)</strong>。预训练模型的参数通常是 <strong>固定不变 (fixed)</strong> 的。通过将原始输入转换成第 2.2 节定义的 <strong>完形填空式 prompt (cloze prompt)</strong> 来检索知识</p>
<p><strong>Linguistic Probing (语言学探测)</strong></p>
<p>除了事实性知识，大规模的预训练也使得语言模型能够处理各种 <strong>语言学现象 (linguistic phenomena)</strong>，比如类比、否定、对语义角色的敏感性、语义相似度、俚语（或行话）理解、以及对稀有词语的理解等。</p>
<h3 id="Classification-based-Tasks-基于分类的任务"><a href="#Classification-based-Tasks-基于分类的任务" class="headerlink" title="Classification-based Tasks (基于分类的任务)"></a>Classification-based Tasks (基于分类的任务)</h3><p><strong>Text Classification (文本分类)</strong></p>
<p>现有的大多数工作都是在 <strong>少样本设置 (few-shot setting)</strong> 下，探索使用 <strong>“固定提示词的语言模型调优”策略 (§7.2.4 中定义的方法)</strong> 来进行文本分类的有效性。这意味着他们使用固定的 prompt 模板，并微调语言模型的部分或全部参数</p>
<p><strong>Natural Language Inference (NLI) (自然语言推理)</strong></p>
<p>自然语言推理（NLI）任务的目标是预测给定<strong>两个句子之间的关系</strong>（例如，一个句子是否蕴含另一个句子 entailment）。</p>
<p>在 prompt engineering 方面，研究人员主要关注于在 <strong>少样本学习设置 (few-shot learning setting)</strong> 下进行 <strong>模板搜索 (template search)</strong>，并且 prompt 中待预测的槽位 [Z] 的 <strong>答案空间 (answer space)</strong>（即可能填充的词语）通常是从词汇表中 <strong>手动预先选择 (manually pre-selected)</strong> 出来，并与最终的类别标签（蕴含、矛盾、中立等）进行映射。</p>
<h3 id="Information-Extraction-信息抽取"><a href="#Information-Extraction-信息抽取" class="headerlink" title="Information Extraction (信息抽取)"></a>Information Extraction (信息抽取)</h3><p><strong>Relation Extraction (关系抽取)</strong></p>
<p>关系抽取任务是预测句子中两个实体之间关系的任务。</p>
<p>(1) <strong>标签空间更大 (The larger label space):</strong> 关系抽取的类别数量通常比二分类任务多很多（例如，关系抽取有 80 种关系，而二分类情感分析只有 2 种情感），这使得 <strong>答案工程 (answer engineering)</strong> 更困难（需要将模型预测的词语映射到更多的关系标签）。 </p>
<p>(2) <strong>输入文本中不同词的重要性不同:</strong> 在关系抽取中，输入句子中的不同词语重要性可能不同（例如，提到实体的词语更有可能与关系相关），但在分类任务中使用的原始 prompt 模板往往平等对待句子中的每个词，难以轻易反映这种差异。</p>
<p><strong>自适应的答案选择方法 (adaptive answer selection method)</strong> 来解决问题 (1)，并针对问题 (2) 构建了 <strong>面向任务的 prompt 模板 (task-oriented prompt template construction)</strong>。在后者中，他们使用特殊的标记（例如 [E]）在模板中高亮实体提及的位置，以此来区分不同词语的重要性。</p>
<p><strong>Semantic Parsing (语义解析)</strong></p>
<p>语义解析任务是给定一个自然语言输入，生成其对应的结构化意义表示（比如将其转换为某种程序语言或逻辑形式）</p>
<h3 id="“Reasoning”-in-NLP-自然语言处理中的“推理”"><a href="#“Reasoning”-in-NLP-自然语言处理中的“推理”" class="headerlink" title="“Reasoning” in NLP (自然语言处理中的“推理”)"></a>“Reasoning” in NLP (自然语言处理中的“推理”)</h3><p><strong>Commonsense Reasoning (常识推理)</strong></p>
<p>一些常见的常识推理任务包括解决 <strong>Winograd Schemas</strong>（由 Levesque 等人提出的一种句子对），这类任务要求模型识别上下文中一个歧义代词（如 it, he, she）的先行词（它指代的是谁）；或者是在给定多个选项的情况下完成一个句子。</p>
<p>对于前者（Winograd Schemas），一个例子是：“奖杯放不进棕色的手提箱，因为它太大了。” 模型需要推理出“it”指的是奖杯还是手提箱</p>
<p>通过在原句子中将“it”替换成可能的先行词（如“奖杯”和“手提箱”），并计算不同选项（替换后的句子）的概率，预训练语言模型可以通过选择概率最高的那个选项来取得相当不错的效果（引用了 Trinh 和 Le 的研究）</p>
<p>对于后者（给定选项完成句子），一个例子是：“埃莉诺提出给她的访客煮些咖啡。然后她意识到她没有干净的 [Z]。” 备选答案是“杯子 (cup)”、“碗 (bowl)”和“勺子 (spoon)”。</p>
<p>对于这类任务，我们同样可以计算每个备选词语（填充到 [Z] 位置后）的生成概率，并选择概率最高的那个作为答案（引用了 Ettinger 的研究）。这同样是利用模型预测概率的 Prompting 方式。</p>
<p><strong>Mathematical Reasoning (数学推理)</strong></p>
<p>在预训练语言模型的背景下，研究人员发现，当数字位数较少时，预训练的 embedding 和语言模型可以执行简单的加法和减法等运算，<strong>但当数字变大时就会失败</strong>（列出了一些相关研究）</p>
<p>Reynolds 和 McDonell (2021) 探索了更复杂的数学推理问题（例如，如果 f(x) &#x3D; x * x，那么 f(f(3)) 是多少？）。他们通过将问题的推理过程 <strong>序列化 (serializing reasoning)</strong>（一步一步地展开推理过程，比如先计算 f(3)，再计算 f(f(3))），从而提高了语言模型在这类问题上的性能。<strong>这暗示了通过将推理步骤融入到 prompt 的结构或内容中来引导模型进行链式思考。</strong></p>
<h3 id="Question-Answering-问答"><a href="#Question-Answering-问答" class="headerlink" title="Question Answering (问答)"></a>Question Answering (问答)</h3><p> 问答任务有多种不同的格式，比如：</p>
<ul>
<li><strong>抽取式问答 (extractive QA):</strong> 答案直接从上下文文档中抽取（例如 SQuAD 数据集）。</li>
<li><strong>多项选择问答 (multiple-choice QA):</strong> 模型需要从几个备选答案中选择一个（例如 RACE 数据集）。</li>
<li><strong>自由生成式问答 (free-form QA):</strong> 模型可以生成任意的文本字符串作为回答（例如 NarrativeQA 数据集）。</li>
</ul>
<p>使用语言模型（并且结合 Prompting 方法）来解决问答问题的一个好处是，可以将不同格式的 QA 任务在 <strong>同一个统一的框架 (same framework)</strong> 下解决。</p>
<p>但也有研究发现，直接依赖模型预测的概率来判断 QA 答案的正确性可能不太可靠。</p>
<h3 id="Text-Generation-文本生成"><a href="#Text-Generation-文本生成" class="headerlink" title="Text Generation (文本生成)"></a>Text Generation (文本生成)</h3><p>Prompting 方法可以很容易地应用于这些任务，通常是结合使用 <strong>前缀式 prompt (prefix prompts)</strong> 和 <strong>自回归预训练语言模型 (autoregressive pre-trained LMs)</strong></p>
<p>Schick 和 Schütze (2020) 探索了在少样本文本摘要任务中使用第 7.2.4 节描述的 <strong>固定提示词的语言模型调优 (fixed-prompt LM tuning)</strong> 方法，他们使用了手动设计的模板并微调语言模型。</p>
<p>Li 和 Liang (2021) 在少样本设置下的文本摘要和数据到文本生成（data-to-text generation，即将结构化数据转换为自然语言文本）任务中，研究了第 7.2.3 节描述的 <strong>固定语言模型的提示词调优 (fixed-LM prompt tuning)</strong> 方法。他们的方法是在输入前面加上一些 <strong>可学习的前缀 token (learnable prefix tokens)</strong>（即软 prompt 的一种），同时保持预训练模型的参数固定不变。</p>
<p> Dou 等人 (2021) 在文本摘要任务中探索了第 7.2.5 节描述的 <strong>提示词 + 语言模型调优 (prompt+LM tuning)</strong> 策略。他们使用了 <strong>可学习的前缀 prompt (learnable prefix prompts)</strong>，并通过不同类型的引导信号进行初始化，然后这些可学习的 prompt 参数可以与预训练语言模型的参数一起进行更新（联合训练）。</p>
<h3 id="Automatic-Evaluation-of-Text-Generation-文本生成的自动评估"><a href="#Automatic-Evaluation-of-Text-Generation-文本生成的自动评估" class="headerlink" title="Automatic Evaluation of Text Generation (文本生成的自动评估)"></a>Automatic Evaluation of Text Generation (文本生成的自动评估)</h3><p>Yuan 等人 (2021b) 的研究表明，prompt learning（基于 prompt 的学习方法）可以用于对生成的文本进行 <strong>自动评估 (automated evaluation)</strong>。这意味着他们不用传统评估指标（如 BLEU），而是利用 Prompting 的方式让模型自己来评估生成文本的质量</p>
<p>他们通过实验发现，在使用预训练模型进行（机器翻译）评估时，仅仅在被评估的翻译文本中加入一个简单的短语“such as”（例如将原文、机器翻译结果以及“such as”一起作为 prompt 的一部分输入模型），就能在德语-英语机器翻译（MT）的评估中，显著提高评估结果与人工判断结果的 <strong>相关性 (correlation)</strong>。</p>
<h3 id="Multi-modal-Learning-多模态学习"><a href="#Multi-modal-Learning-多模态学习" class="headerlink" title="Multi-modal Learning (多模态学习)"></a>Multi-modal Learning (多模态学习)</h3><p>Tsimpoukelli 等人 (2021) 将 prompt learning 的应用从纯文本的自然语言处理领域，转移到了 <strong>多模态设置 (multi-modal setting)</strong>，具体是结合了 <strong>视觉 (vision)</strong> 和 <strong>语言 (language)</strong>。</p>
<p>他们采用了前面第 7.2.3 节讨论的 <strong>固定语言模型的提示词调优策略 (fixed-LM prompt tuning strategy)</strong>，并结合了 <strong>提示词增强 (prompt augmentation)</strong> 技术。</p>
<p>具体来说，他们将每一张图像表示为一个 <strong>连续的 embedding 序列 (sequence of continuous embeddings)</strong>。然后，他们使用一个参数 <strong>固定（frozen）</strong> 的预训练语言模型，将这个图像 embedding 序列作为 <strong>前缀 (prefix)</strong> 输入给模型，让模型去生成文本，比如 <strong>图像描述 (image captions)</strong>。</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://www.gravatar.com/avatar/96bd83aac6004b898e6081975c10f344?s=128" alt="SAI_MUD"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">SAI_MUD</p><p class="is-size-6 is-block">无名小卒</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Chengdu</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">28</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/fatecantkillme" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/fatecantkillme"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Weibo" href="https://m.weibo.cn/profile/7024554023"><i class="fab fa-weibo"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/DL/"><span class="level-start"><span class="level-item">DL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%93%B2%E5%AD%A6/"><span class="level-start"><span class="level-item">哲学</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BF%83%E7%90%86%E5%AD%A6/"><span class="level-start"><span class="level-item">心理学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"><span class="level-start"><span class="level-item">数学建模</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"><span class="level-start"><span class="level-item">碎碎念</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A4%BE%E4%BC%9A%E5%AD%A6/"><span class="level-start"><span class="level-item">社会学</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">精神分析</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BB%8F%E6%B5%8E/"><span class="level-start"><span class="level-item">经济</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-20T12:32:00.000Z">2025-05-20</time></p><p class="title"><a href="/2025/05/20/%E6%8B%89%E5%BA%B7%E6%80%9D%E6%83%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%90%86%E8%AE%BA%E6%A8%A1%E5%9E%8B/">拉康思想的基本概念及理论模型</a></p><p class="categories"><a href="/categories/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90/">精神分析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-10T06:56:35.000Z">2025-05-10</time></p><p class="title"><a href="/2025/05/10/NLP1/">Pre-train, Prompt, and Predict A Systematic Survey of Prompting Methods in Natural Language Processing</a></p><p class="categories"><a href="/categories/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-25T02:58:07.000Z">2025-04-25</time></p><p class="title"><a href="/2025/04/25/pytorch&amp;DL/">pytorch&amp;DL tutorial (LiMu)</a></p><p class="categories"><a href="/categories/DL/">DL</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-24T03:23:46.000Z">2025-04-24</time></p><p class="title"><a href="/2025/04/24/pandas%E6%95%99%E7%A8%8B/">pandas tutorial</a></p><p class="categories"><a href="/categories/python/">python</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-05T12:23:46.000Z">2025-04-05</time></p><p class="title"><a href="/2025/04/05/%E6%8B%89%E5%BA%B7%E5%BC%8F%E4%B8%BB%E4%BD%93/">拉康式主体</a></p><p class="categories"><a href="/categories/%E5%93%B2%E5%AD%A6/">哲学</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/05/"><span class="level-start"><span class="level-item">May 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/04/"><span class="level-start"><span class="level-item">April 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">March 2025</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/DL/"><span class="tag">DL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ML/"><span class="tag">ML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NLP/"><span class="tag">NLP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NLP%E5%85%A5%E9%97%A8/"><span class="tag">NLP入门</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/prompt-engine/"><span class="tag">prompt engine</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pytorch/"><span class="tag">pytorch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%8E%E7%BB%93%E6%9E%84%E4%B8%BB%E4%B9%89/"><span class="tag">后结构主义</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%93%B2%E5%AD%A6/"><span class="tag">哲学</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7/"><span class="tag">弗洛伊德</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BD%93%E4%BB%A3%E6%96%87%E5%AD%A6/"><span class="tag">当代文学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BD%93%E4%BB%A3%E8%89%BA%E6%9C%AF/"><span class="tag">当代艺术</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"><span class="tag">心理学</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8B%89%E5%BA%B7/"><span class="tag">拉康</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"><span class="tag">数学建模</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"><span class="tag">数据处理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%A8%A1/"><span class="tag">数模</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B3%95%E5%85%B0%E5%85%8B%E7%A6%8F%E5%AD%A6%E6%B4%BE/"><span class="tag">法兰克福学派</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%95%85%E9%94%80%E4%B9%A6/"><span class="tag">畅销书</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A4%BE%E4%BC%9A%E5%AD%A6/"><span class="tag">社会学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90/"><span class="tag">精神分析</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%8F%E6%B5%8E/"><span class="tag">经济</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%9D%E5%AF%B9%E5%94%AF%E5%BF%83%E4%B8%BB%E4%B9%89/"><span class="tag">绝对唯心主义</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E6%9D%82%E8%B0%88/"><span class="tag">网络杂谈</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8D%A3%E6%A0%BC/"><span class="tag">荣格</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95/"><span class="tag">评价方法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9B%86%E4%BD%93%E6%BD%9C%E6%84%8F%E8%AF%86/"><span class="tag">集体潜意识</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%BB%91%E6%A0%BC%E5%B0%94/"><span class="tag">黑格尔</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">SAI</a><p class="is-size-7"><span>&copy; 2025 SAI_MUD</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2025</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>